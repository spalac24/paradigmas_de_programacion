module Main where

import SafeCalls
import Config
import CurryToHaskell hiding (consName)
import FunctionalProg
import Debug.Trace
import Names hiding (consName)
import System.Environment
import List

main = safe $ do
  as <- safeIO getArgs
  let dir = if null as then "" else head as
  (opts,_) <- safeIO readConfig
  callFrontend opts{filename="Generate"}
  curryProg <- safeReadFlat opts "Generate.fcy"
  let [(_,_,prog)] = transform tMap undefined opts curryProg
      file1 = "AutoGenerated1"
      auto1 = emptyProg {progName=file1,
                         imports=["Curry"],
                         typeDecls=map correctTD (filter inAuto1 $ typeDecls prog)}
  writeProgram opts (dir++file1++".hs",True,auto1)
  safeIO $ putStrLn ("File "++dir++file1++".hs written")
  let file2 = "AutoGenerated2"
      auto2 = emptyProg {progName=file2,
                         imports=["Curry",dataModName "Prelude"],
                         instanceDecls=filter inAuto2 $
                                        --map (repairID rename) $ 
                                         --filter goodInstances $ 
                                       instanceDecls prog,
                         funcDecls=funcDecls prog}
  writeProgram opts (dir++file2++".hs",True,auto2)
  safeIO $ putStrLn ("File "++dir++file2++".hs written")



correctTD t@Type{typeName=(m,"C_List")} = noC_ t
correctTD t@Type{typeName=(m,"C_Prim")} = noC_ t
correctTD t@Type{typeName=(m,"C_Char")} = correctPrim t
correctTD t@Type{typeName=(m,"C_Int")}  = correctPrim t
correctTD t@Type{typeName=(m,"C_Four")} = t{derive=nub ("Eq":derive t)}
correctTD t = t

noC_ t@Type{typeName=(m,'C':'_':n),consDecls=cs} =  
  t{typeName=(m,n),consDecls=map noC_ConsDecl  cs}

noC_ConsDecl c@Cons{consName = (m,'C':'_':name),consArgs=args} = 
  c{consName = (m,name),consArgs = map noC_Args args}
noC_ConsDecl c@Cons{consArgs=args} = c{consName = ("",":<"),consArgs = map noC_Args args}

noC_Args x@(TVar _) = x
noC_Args (FuncType t1 t2) = FuncType (noC_Args t1) (noC_Args t2)
noC_Args t@(TCons (_,"C_Exceptions") []) = t
noC_Args (TCons (m,'C':'_':n) ts) = TCons (m,n) (map noC_Args ts)
noC_Args (TCons n ts) = TCons n  (map noC_Args ts)

correctPrim t@Type{consDecls=c:cs} = t {consDecls=correctP c:cs}

correctP c@Cons{consName = (m,n)} = c{consArgs=[TCons ("",newName n) []],strictArgs=True}

newName "C_Char" = "Char"
newName "C_Int" =  "Integer"


inAuto1 t = not $ elem (snd (typeName t)) ["C_Success","C_Bool","C_Char"]

inAuto2 i = not $ elem (snd (className inst)) ["Show","Read","Curry"] || 
                  elem tName ["C_Char","C_Prim"] 
  where
    inst  = instanciated i
    tName = name $ head $ classArgs inst
    name (TCons (_,n) _) = n

goodInstances i = 
  not (elem (name $ head $ classArgs $ instanciated i) 
            ["C_Success","C_Bool","C_Char","C_Int","C_Prim"]) &&
  if elem (snd $ className $ instanciated i) ["Show","Read"]
    then not (elem (name $ head $ classArgs $ instanciated i) 
                   ["C_List","C_Int","C_Char","C_Prim"])
    else True
  where
    name (TCons (_,n) _) = n

rename ("DataGenerate",n) = rename ("PrepareBaseTypes",n)
rename ("CurryGenerateCTC",n) = rename ("PrepareBaseTypes",n)
rename ("DataPrelude",n) = rename ("PrepareBaseTypes",n)
rename (m,'C':'_':'L':'i':'s':'t':n)   = (m,"List"++n)
rename (m,'C':'_':'P':'r':'i':'m':n)   = (m,"Prim"++n)
rename (m,"C_:<")     = (m,":<")
rename x = x

tMap (m,"True") = (m,"Bool")
tMap (m,"False") = (m,"Bool")
tMap x = x


----------------------------------
-- repairing
----------------------------------

repair f prog@Prog{typeDecls=tds,instanceDecls=ids} = 
  prog{typeDecls=map (repairTD f) tds,
       instanceDecls=map (repairID f) ids}

repairTD f t@Type{typeName=n,consDecls=cds} = 
  t{typeName=f n,
    consDecls=map (repairCD f) cds}
repairTD f t@TypeSyn{typeName=n,typeExpr=e} = 
  t{typeName=f n,
    typeExpr=repairTE f e}

repairID f i@Instance{instanciated=inst,instanceFunc=fds} = 
  i{instanciated=repairTC f inst,
    instanceFunc = map (repairFD f) fds}

repairTC f tc@TypeClass { className=n,classArgs=tes} =
  tc{className=f n,
     classArgs= map (repairTE f) tes}


repairCD f c@Cons { consName=n,consArgs=tes} = 
  c{consName=f n,
    consArgs=map (repairTE f) tes}

repairTE f x@(TVar _) = x
repairTE f (FuncType t1 t2) = FuncType (repairTE f t1) (repairTE f t2)
repairTE f (TCons n tes) = TCons (f n) (map (repairTE f) tes)
repairTE f (TConstr tcs te) = TConstr (map (repairTC f) tcs) (repairTE f te)


repairFD f func@Func{ funcName=fn,funcType=mft,funcBody=fb} =
  func{ funcName=f fn,
        funcType=maybe Nothing (Just. repairTE f) mft,
        funcBody=maybe Nothing (Just . map (repairR f)) fb}


repairR f r@Rule { patterns=ps,rhs=rhs,locDecls=ls} =
  r { patterns=map (repairP f) ps,
      rhs=repairRhs f rhs,
      locDecls=map (repairLD f) ls}

repairRhs f (SimpleExpr e) = SimpleExpr (repairE f e)
repairRhs f (GuardedExpr ges) = 
 GuardedExpr ( map (\ (x,y) -> (repairE f x,repairE f y)) ges)

repairLD f (LocalFunc fd) = LocalFunc (repairFD f fd)
repairLD f (LocalPat p e lds) = 
  LocalPat (repairP f p) (repairE f e) (map (repairLD f) lds)

repairE f (Symbol n) = Symbol (f n)
repairE f (Apply e1 e2) = Apply (repairE f e1) (repairE f e2)
repairE f (Lambda ps e) = Lambda  (map (repairP f) ps) (repairE f e)
repairE f (LetDecl  lds e) = LetDecl (map (repairLD f) lds) (repairE f e)
repairE f (DoExpr xs) = DoExpr (map (repairS f) xs)
repairE f (ListComp e xs) = ListComp (repairE f e) (map (repairS f) xs)
repairE f (Case e bs) = Case (repairE f e) (map (repairB f) bs)
repairE _ x = x

repairS f (SExpr e) = SExpr (repairE f e)
repairS f (SPat p e) = SPat (repairP f p) (repairE f e)
repairS f (SLet lds) = SLet (map (repairLD f) lds)

repairP f (PComb n ps) = PComb (f n) (map (repairP f) ps)
repairP f (AsPat n p) = AsPat n (repairP f p)
repairP f x = x

repairB f (Branch p e)= Branch (repairP f p) (repairE f e)