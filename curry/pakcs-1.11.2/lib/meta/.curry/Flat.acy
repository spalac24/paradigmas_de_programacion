CurryProg "Flat"
 ["Prelude","Directory","Char","Distribution"]
 [CType ("Flat","Prog") Public [] [CCons ("Flat","Prog") 6 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","[]") [CTCons ("Prelude","String") []],CTCons ("Prelude","[]") [CTCons ("Flat","TypeDecl") []],CTCons ("Prelude","[]") [CTCons ("Flat","FuncDecl") []],CTCons ("Prelude","[]") [CTCons ("Flat","OpDecl") []],CTCons ("Prelude","[]") [CTCons ("Flat","Translation") []]]],
  CTypeSyn ("Flat","TVarIndex") Public [] (CTCons ("Prelude","Int") []),
  CType ("Flat","TypeDecl") Public [] [CCons ("Flat","Type") 3 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","[]") [CTCons ("Flat","TVarIndex") []],CTCons ("Prelude","[]") [CTCons ("Flat","ConsDecl") []]]],
  CType ("Flat","ConsDecl") Public [] [CCons ("Flat","Cons") 3 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","Int") [],CTCons ("Prelude","[]") [CTCons ("Flat","TypeExpr") []]]],
  CType ("Flat","TypeExpr") Public [] [CCons ("Flat","TVar") 1 Public [CTCons ("Flat","TVarIndex") []],CCons ("Flat","FuncType") 2 Public [CTCons ("Flat","TypeExpr") [],CTCons ("Flat","TypeExpr") []],CCons ("Flat","TCons") 2 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","[]") [CTCons ("Flat","TypeExpr") []]]],
  CType ("Flat","OpDecl") Public [] [CCons ("Flat","Op") 3 Public [CTCons ("Prelude","String") [],CTCons ("Flat","Fixity") [],CTCons ("Prelude","Int") []]],
  CType ("Flat","Fixity") Public [] [CCons ("Flat","InfixOp") 0 Public [],CCons ("Flat","InfixlOp") 0 Public [],CCons ("Flat","InfixrOp") 0 Public []],
  CTypeSyn ("Flat","VarIndex") Public [] (CTCons ("Prelude","Int") []),
  CType ("Flat","FuncDecl") Public [] [CCons ("Flat","Func") 4 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","Int") [],CTCons ("Flat","TypeExpr") [],CTCons ("Flat","Rule") []]],
  CType ("Flat","Rule") Public [] [CCons ("Flat","Rule") 2 Public [CTCons ("Prelude","[]") [CTCons ("Flat","VarIndex") []],CTCons ("Flat","Expr") []],CCons ("Flat","External") 1 Public [CTCons ("Prelude","String") []]],
  CType ("Flat","CaseType") Public [] [CCons ("Flat","Rigid") 0 Public [],CCons ("Flat","Flex") 0 Public []],
  CType ("Flat","CombType") Public [] [CCons ("Flat","FuncCall") 0 Public [],CCons ("Flat","ConsCall") 0 Public [],CCons ("Flat","PartCall") 0 Public []],
  CType ("Flat","Expr") Public [] [CCons ("Flat","Var") 1 Public [CTCons ("Flat","VarIndex") []],CCons ("Flat","Lit") 1 Public [CTCons ("Flat","Literal") []],CCons ("Flat","Comb") 3 Public [CTCons ("Flat","CombType") [],CTCons ("Prelude","String") [],CTCons ("Prelude","[]") [CTCons ("Flat","Expr") []]],CCons ("Flat","Apply") 2 Public [CTCons ("Flat","Expr") [],CTCons ("Flat","Expr") []],CCons ("Flat","Constr") 2 Public [CTCons ("Prelude","[]") [CTCons ("Flat","VarIndex") []],CTCons ("Flat","Expr") []],CCons ("Flat","Or") 2 Public [CTCons ("Flat","Expr") [],CTCons ("Flat","Expr") []],CCons ("Flat","Case") 3 Public [CTCons ("Flat","CaseType") [],CTCons ("Flat","Expr") [],CTCons ("Prelude","[]") [CTCons ("Flat","BranchExpr") []]],CCons ("Flat","Let") 2 Public [CTCons ("Prelude","[]") [CTCons ("Prelude","(,)") [CTCons ("Flat","VarIndex") [],CTCons ("Flat","Expr") []]],CTCons ("Flat","Expr") []],CCons ("Flat","Choice") 1 Public [CTCons ("Flat","Expr") []],CCons ("Flat","GuardedExpr") 3 Public [CTCons ("Prelude","[]") [CTCons ("Flat","VarIndex") []],CTCons ("Flat","Expr") [],CTCons ("Flat","Expr") []]],
  CType ("Flat","BranchExpr") Public [] [CCons ("Flat","Branch") 2 Public [CTCons ("Flat","Pattern") [],CTCons ("Flat","Expr") []]],
  CType ("Flat","Pattern") Public [] [CCons ("Flat","Pattern") 2 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","[]") [CTCons ("Flat","VarIndex") []]],CCons ("Flat","LPattern") 1 Public [CTCons ("Flat","Literal") []]],
  CType ("Flat","Literal") Public [] [CCons ("Flat","Intc") 1 Public [CTCons ("Prelude","Int") []],CCons ("Flat","Floatc") 1 Public [CTCons ("Prelude","Float") []],CCons ("Flat","Charc") 1 Public [CTCons ("Prelude","Char") []]],
  CType ("Flat","Translation") Public [] [CCons ("Flat","Trans") 2 Public [CTCons ("Prelude","String") [],CTCons ("Prelude","String") []]]]
 [CFunc ("Flat","readFlatCurry") 1 Public (CFuncType (CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]) (CTCons ("Prelude","IO") [CTCons ("Flat","Prog") []])) (CRules CFlex [CRule [CPVar (0,"progfile")] [(CSymbol ("Prelude","success"),CApply (CApply (CSymbol ("Flat","readFlatCurryWithParseOptions")) (CVar (0,"progfile"))) (CApply (CApply (CSymbol ("Distribution","setQuiet")) (CSymbol ("Prelude","True"))) (CSymbol ("Distribution","defaultParams"))))] []]),
  CFunc ("Flat","readFlatCurryWithParseOptions") 2 Public (CFuncType (CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]) (CFuncType (CTCons ("Distribution","FrontendParams") []) (CTCons ("Prelude","IO") [CTCons ("Flat","Prog") []]))) (CRules CFlex [CRule [CPVar (0,"progname"),CPVar (1,"options")] [(CSymbol ("Prelude","success"),CDoExpr [CSPat (CPVar (2,"existsCurry")) (CApply (CSymbol ("Directory","doesFileExist")) (CApply (CApply (CSymbol ("Prelude","++")) (CVar (0,"progname"))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc '.'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'c'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'u'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'y'))) (CSymbol ("Prelude","[]")))))))))),CSPat (CPVar (3,"existsLCurry")) (CApply (CSymbol ("Directory","doesFileExist")) (CApply (CApply (CSymbol ("Prelude","++")) (CVar (0,"progname"))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc '.'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'l'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'c'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'u'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'y'))) (CSymbol ("Prelude","[]"))))))))))),CSExpr (CApply (CApply (CApply (CSymbol ("Prelude","if_then_else")) (CApply (CApply (CSymbol ("Prelude","||")) (CVar (2,"existsCurry"))) (CVar (3,"existsLCurry")))) (CApply (CApply (CApply (CSymbol ("Distribution","callFrontendWithParams")) (CSymbol ("Distribution","FCY"))) (CVar (1,"options"))) (CVar (0,"progname")))) (CSymbol ("Prelude","done"))),CSPat (CPVar (4,"filename")) (CApply (CSymbol ("Distribution","findFileInLoadPath")) (CApply (CApply (CSymbol ("Prelude","++")) (CVar (0,"progname"))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc '.'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'f'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'c'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'y'))) (CSymbol ("Prelude","[]")))))))),CSExpr (CApply (CSymbol ("Flat","readFlatCurryFile")) (CVar (4,"filename")))])] []]),
  CFunc ("Flat","readFlatCurryFile") 1 Public (CFuncType (CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]) (CTCons ("Prelude","IO") [CTCons ("Flat","Prog") []])) (CRules CFlex [CRule [CPVar (0,"fname")] [(CSymbol ("Prelude","success"),CApply (CApply (CSymbol ("Prelude","$##")) (CSymbol ("Flat","prim_readFlatCurryFile"))) (CVar (0,"fname")))] []]),
  CFunc ("Flat","prim_readFlatCurryFile") 1 Public (CFuncType (CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]) (CTCons ("Prelude","IO") [CTCons ("Flat","Prog") []])) (CExternal "prim_readFlatCurryFile"),
  CFunc ("Flat","splitFlatModName") 1 Public (CFuncType (CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]) (CTCons ("Prelude","(,)") [CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []],CTCons ("Prelude","[]") [CTCons ("Prelude","Char") []]])) (CRules CFlex [CRule [CPVar (0,"name")] [(CApply (CSymbol ("Char","isAlpha")) (CApply (CSymbol ("Prelude","head")) (CVar (0,"name"))),CLetDecl [CLocalPat (CPComb ("Prelude","(,)") [CPVar (1,"modname"),CPVar (2,"rname")]) (CApply (CApply (CSymbol ("Prelude","break")) (CLambda [CPVar (3,"x0")] (CApply (CApply (CSymbol ("Prelude","==")) (CVar (3,"x0"))) (CLit (CCharc '.'))))) (CVar (0,"name"))) []] (CApply (CApply (CApply (CSymbol ("Prelude","if_then_else")) (CApply (CApply (CSymbol ("Prelude","==")) (CVar (2,"rname"))) (CSymbol ("Prelude","[]")))) (CApply (CApply (CSymbol ("Prelude","(,)")) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'P'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'e'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'l'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'u'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'd'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'e'))) (CSymbol ("Prelude","[]")))))))))) (CVar (0,"name")))) (CApply (CApply (CSymbol ("Prelude","(,)")) (CVar (1,"modname"))) (CApply (CSymbol ("Prelude","tail")) (CVar (2,"rname")))))),(CSymbol ("Prelude","otherwise"),CApply (CApply (CSymbol ("Prelude","(,)")) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'P'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'r'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'e'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'l'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'u'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'd'))) (CApply (CApply (CSymbol ("Prelude",":")) (CLit (CCharc 'e'))) (CSymbol ("Prelude","[]")))))))))) (CVar (0,"name")))] []])]
 []
